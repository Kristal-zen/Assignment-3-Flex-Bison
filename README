README
Name: Jesyl Zendejas 
REDID: 820972081
Class EDORAS Account: cssc2146 

Description:
This projects aim is to implement a statment parser whose job is o validate and evaluate statements based on set restrictions on grammer. The parser will accept the following: 
      I. Assignemnts in the form of: id = expression;
      II. Expressions in the form of: id op id { op id }
Where each line in the input text file is treated as its own seperate statement. the program will read statements from a file (scanme.txt for example) then parses them and will print one of the following:
      I. valid
      II. invalid: <reason>
With the reason including information like: invalid tokens and malformed assignemnts or expresssions. Overall this project wil use flex for scanning and bison for parsing and is compiled using gcc.

File Manifest:
- scanner.l                       # This is the flex scanner which tokenizes the following: operators, identifiers, parenthesis, assignments and any invalid tokens
- parser.y                        # The bison grammer which defines valid expression rules and assignemnts
- main.c                          # The program driver that is in charge of: loading the input file, processing one line at a time and will reset the parser state when appropriate
- scanme.txt                      # This is the sample input file that contains either valid or invalid statements 
- Makefile                        # In charge of automating the compilation using bison, flex and gcc
- parcer.tab.c/ parder.tab.h      # Generated by Bison
- lex.yy.c                        # Generated by Flex
- scanner.exe                     # Executable made after compilation


Compile Instructions:
In order to ensure that the program will run properly you must:
	1. First and foremost, ensure that you are in the correct directory which is: a3, you can reach this by running the command: cd a3.
  2. Run these commands in this order (that is if it's the first time you're trying to compile the file): 
    bison -d parser.y
    flex scanner.l
    gcc -Wall -Wextra -O2 -o scanner parser.tab.c lex.yy.c main.c
  3. This will leave you with your executable that has been produced in the file, now you can run scanner.exe with file of choice, here is an example:
      Example: scanner <yourfilehere.txt>

Operating Instruction:
Here are the steps to follow in order to use the program to it's full potential:
  1. Make sure that you are in the right directory (a3) and ensure that your input file is included in this directory.
  2. Next you want to run this command: scanner <testfile.txt> with testfile replaced with your file of choice.
  3. From here you can see that the program wll print each of the statements followed by either a '-- valid' or  '-- invalid: <reason>'
  4. Each line from the file will be parsed independently from one and other, keeping in mind that all blank lines are ignored

Design Decisions:
  Identifiers: For identifiers, a letter followed by letters or digits is allowed with pure digits treated as IDs. Example: 2two is considered invalid and flagged at an earlier stage.
  Operators: For operateors only the following are recognized: +, -, *, /, % with any other operators being considered an invalid token
  Assignment recognition: If an equal sign (=) appears anywhere within the line its dealing with then the parser will treat it as an attempt to assign. If an assignment happens to fail then that will lead to an 'invalid assignment' result.
  Error Reporting: The first invalid token will be caught by the scanner, if there are no invalid tokens but the grammer still fails then that means that A. if an assignment was attempted = issue with invalid assignment, or B. otherwise, that means that it is an issue with an invalid expression.

Description of all known deficiencies or bugs:

Lessons Learned:
Working on this project has provided a lot of insight when it came to the following topics: 
-Flex and Bison Integration:
    When working with and building a working scanner parser pipeline, it is ritual for the flex patterns to be written carefully in a way to make sure those patterns are always respected/ upheld.
-Error handling as a design Problem:
  Bison's yyerror must be customized in order to easily be able to tell the different between invalid tokens, assignment errors and expression errors. In order to have a way to track errors and build informative messages required an additional parser state.
-Incremental Debugging: 
  There were issues early on when trying to complete the task of the assignment but there was trouble where there was "unrecognized rules" in he flex. I looked deeper into it and finally realized these errors were made by comments made in the rule section. The trial and error with the flex portion has made it clear how small syntax issues can cause confusion when it comes to scanner errors.
